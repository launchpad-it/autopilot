// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jobs.sql

package sqlc

import (
	"context"
	"time"
)

const insertJob = `-- name: InsertJob :exec
insert into jobs (
    id,
    source,
    published_at,
    link,
    title,
    description,
    ai_company,
    ai_role,
    ai_seniority,
    ai_overview,
    ai_hashtags
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
)
`

type InsertJobParams struct {
	ID          string     `json:"id"`
	Source      string     `json:"source"`
	PublishedAt *time.Time `json:"published_at"`
	Link        string     `json:"link"`
	Title       string     `json:"title"`
	Description string     `json:"description"`
	CompanyAI   string     `json:"ai_company"`
	RoleAI      string     `json:"ai_role"`
	SeniorityAI string     `json:"ai_seniority"`
	OverviewAI  string     `json:"ai_overview"`
	HashtagsAI  []string   `json:"ai_hashtags"`
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) error {
	_, err := q.db.Exec(ctx, insertJob,
		arg.ID,
		arg.Source,
		arg.PublishedAt,
		arg.Link,
		arg.Title,
		arg.Description,
		arg.CompanyAI,
		arg.RoleAI,
		arg.SeniorityAI,
		arg.OverviewAI,
		arg.HashtagsAI,
	)
	return err
}

const jobsExist = `-- name: JobsExist :many
select id from jobs where id = any($1)
`

func (q *Queries) JobsExist(ctx context.Context, ids []string) ([]string, error) {
	rows, err := q.db.Query(ctx, jobsExist, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scoredJobs = `-- name: ScoredJobs :many
with ranked as (
    select
        j.id,
        j.source,
        j.published_at,
        j.link,
        j.title,
        j.description,
        j.ai_company,
        j.ai_role,
        j.ai_seniority,
        j.ai_overview,
        j.ai_hashtags,

        /* tech keywords overlap */
        cardinality(array(
            select unnest(j.ai_hashtags)
            intersect
            select unnest($2::text[])
        ))::numeric
        as tech_match,

        /* resume keywords overlap */
        (
            select count(*)
            from unnest(j.ai_hashtags) as tag
            where exists (
                select 1
                from unnest($3::text[]) as kw
                where tag ilike kw
            )
        )::numeric
        as cv_match,

        /* role keyword match */
        case
            when j.ai_role ilike any ($4::text[])
            then 1
            else 0
        end::numeric
        as role_match,

        /* simple seniority weight */
        case j.ai_seniority
            when 'Junior' then 1.0
            when 'Middle' then 0.7
            else               0.4
            end
        as seniority_boost
    from
        jobs as j
    left join user_jobs as uj
        on uj.job_id = j.id and uj.user_id = $5
    where
        uj.job_id is null
)
select
    id,
    source,
    published_at,
    link,
    title,
    description,
    ai_company,
    ai_role,
    ai_seniority,
    ai_overview,
    ai_hashtags,
    /* final weighted score */
    (
        tech_match +
        cv_match * 0.7 +
        role_match * 0.8 +
        seniority_boost
    )::double precision
    as score
from
    ranked
order by
    score desc,
    published_at desc
limit
    $1
`

type ScoredJobsParams struct {
	Limit          int32    `json:"limit"`
	Hashtags       []string `json:"hashtags"`
	ResumeKeywords []string `json:"resume_keywords"`
	RolePatterns   []string `json:"role_patterns"`
	UserID         int64    `json:"user_id"`
}

type ScoredJobsRow struct {
	ID          string     `json:"id"`
	Source      string     `json:"source"`
	PublishedAt *time.Time `json:"published_at"`
	Link        string     `json:"link"`
	Title       string     `json:"title"`
	Description string     `json:"description"`
	CompanyAI   string     `json:"ai_company"`
	RoleAI      string     `json:"ai_role"`
	SeniorityAI string     `json:"ai_seniority"`
	OverviewAI  string     `json:"ai_overview"`
	HashtagsAI  []string   `json:"ai_hashtags"`
	Score       float64    `json:"score"`
}

func (q *Queries) ScoredJobs(ctx context.Context, arg ScoredJobsParams) ([]ScoredJobsRow, error) {
	rows, err := q.db.Query(ctx, scoredJobs,
		arg.Limit,
		arg.Hashtags,
		arg.ResumeKeywords,
		arg.RolePatterns,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScoredJobsRow
	for rows.Next() {
		var i ScoredJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.PublishedAt,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.CompanyAI,
			&i.RoleAI,
			&i.SeniorityAI,
			&i.OverviewAI,
			&i.HashtagsAI,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uniqueJobs = `-- name: UniqueJobs :many
select
    created_at, id, source, published_at, link, title, description, ai_company, ai_role, ai_seniority, ai_overview, ai_hashtags
from
    jobs
where
    id not in (
        select job_id
        from user_jobs
        where user_id = $1
    )
order by
    published_at desc
limit
    $2
`

type UniqueJobsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) UniqueJobs(ctx context.Context, arg UniqueJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, uniqueJobs, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.CreatedAt,
			&i.ID,
			&i.Source,
			&i.PublishedAt,
			&i.Link,
			&i.Title,
			&i.Description,
			&i.CompanyAI,
			&i.RoleAI,
			&i.SeniorityAI,
			&i.OverviewAI,
			&i.HashtagsAI,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
